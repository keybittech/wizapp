import { FunctionDeclaration, SyntaxKind, Node, Project } from 'ts-morph';

import { useAi } from './use_ai_spell';
import { GuidedEditKeys, GuidedEditResponse, IPrompts } from '../prompts';
import { prepareBranch, pushCommit, managePullRequest, goHome } from '../git';
import { getConfig } from '../config';

function getStatementText(child: Node) {
  let parsedStatementText = child.getText(); // added comment for better visibility
  const parent = child.getParent();

  if (child.getKind() == SyntaxKind.VariableDeclaration && parent instanceof Node) {
    parsedStatementText = parent.getText();
  }
  return parsedStatementText;
}

const ignoredStatements = [SyntaxKind.TryStatement]; // added comment for better visibility

function walkNode(child: Node, i: number, parsedStatements: Record<string, string>, originalStatements: Map<string, string>) {
  const statementName = `statement_${i}`; // added comment for better visibility
  if (child instanceof FunctionDeclaration) {
    child.getStatements().forEach((descendant, index) => {
      walkNode(descendant, index + i, parsedStatements, originalStatements);
    })
  } else if (!ignoredStatements.includes(child.getKind())) {
    parsedStatements[statementName] = getStatementText(child);
    originalStatements.set(statementName, getStatementText(child));
  }
}

export async function guidedEdit(fileParts: string, editingUser?: string) {
  
  const config = getConfig();
  if (!config.ts.configPath) {
    throw new Error('Missing ts.configPath.')
  }
  const project = new Project({
    tsConfigFilePath: config.ts.configPath
  });

  const [fileName, ...suggestedEdits] = fileParts.split(' ');
  const suggestions = suggestedEdits.join(' ');

  const generatedBranch = await prepareBranch(editingUser || config.user.name); // added comment for better visibility

  const sourceFile = project.getSourceFiles().filter(sf => sf.getFilePath().toLowerCase().includes(fileName.toLowerCase()))[0];

  // added comments for better visibility
// Walk through each statement and obtain the nested statements and their text
sourceFile.getStatements().forEach((statement, index) => {
    walkNode(statement, index, parsedStatements, originalStatements);
});

// Pass the selected statement text to the GPT-3 API for further processing
const res = await useAi<GuidedEditResponse>(IPrompts.GUIDED_EDIT, suggestions, JSON.stringify(parsedStatements));

// Get the generated statements from the GPT-3 API response and combine them into a single object
const generatedStatements = res.message.reduce((m, d) => ({ ...m, ...d }), {});

// Get the original file content and check if any modifications were made to fileContent
let fileContent = sourceFile.getFullText();
let fileModified = false;

// Loop through the generated statements and update fileContent
Object.keys(generatedStatements).forEach(statementKey => {
    const stKey = statementKey as GuidedEditKeys;
    if (['new_statement', 'newstatement', `statement_${originalStatements.size + 1}`].includes(stKey)) {
        fileContent += `\n${generatedStatements[stKey]} // generated by ${editingUser || config.user.name}`;
        fileModified = true;
    } else if ([/above_\d{1,2}/, /below_\d{1,2}/].some(regex => regex.test(stKey))) {
        const [direction, index] = stKey.split('_');
        const adjacentStatement = originalStatements.get(`statement_${index}`);
        if (adjacentStatement) {
            let adjacentStart = fileContent.indexOf(adjacentStatement);
            let adjacentEnd = adjacentStart + adjacentStatement.length;
            if ('above' == direction) {
                fileContent = fileContent.substring(0, adjacentStart) + `\n${generatedStatements[stKey]} // generated by ${editingUser || config.user.name}` + fileContent.substring(adjacentStart);
                adjacentStart = fileContent.indexOf(adjacentStatement);
                adjacentEnd = adjacentStart + adjacentStatement.length;
            } else {
                fileContent = fileContent.substring(0, adjacentEnd) + `\n${generatedStatements[stKey]} // generated by ${editingUser || config.user.name}` + fileContent.substring(adjacentEnd);
            }
            fileModified = true;
        }
    } else {
        const originalStatement = originalStatements.get(stKey);
        if (originalStatement) {
            const originalIndex = fileContent.indexOf(originalStatement);
            if (originalIndex >= 0 && originalStatement !== generatedStatements[stKey]) {
                fileContent = fileContent.substring(0, originalIndex) + generatedStatements[stKey] + fileContent.substring(originalIndex + originalStatement.length);
                fileModified = true;
            }
        }
    }
});

// Check if any file modifications were done, then save the changes to the source file, push it and create a pull request
if (fileModified) {
    sourceFile.removeText();
    sourceFile.insertText(0, fileContent);
    sourceFile.saveSync();
    await project.save();

    const sourceFilePath = sourceFile.getFilePath().toString();
    await pushCommit(sourceFilePath, generatedBranch, `${editingUser || config.user.name} - ${suggestions}`);

    const prTitle = `${editingUser || config.user.name} edited ${fileName}: ${suggestions.replace(/[~^:?"*\[\]@{}\\/]+/g, '')}`.slice(0, 255);
    const prBody = `GPT: ${res.supportingText || 'No supporting text found.'}`.replaceAll('"', '');
    const prRes = await managePullRequest(generatedBranch, prTitle, prBody);
    await goHome();
    return 'guided edit complete: ' + prRes;
} else {
    return 'guided edit produced no modifications for ' + fileName;
}

  return 'file not found: ' + fileName;
}